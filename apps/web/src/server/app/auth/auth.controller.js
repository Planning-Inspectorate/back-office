import msalNode from '@azure/msal-node';
import { promisify } from 'node:util';
import pino from '../../lib/logger.js';
import * as authService from './auth.service.js';
import * as authSession from './auth-session.service.js';

/**
 * Phase 1 – Navigate to external MSAL signin url
 *
 * Begin the MSAL OpenID Connect (OIDC) flow for an unauthenticated user by
 * forwarding them to the MSAL signin url. After signing in, the user will be
 * redirected by MSAL back to our application with an authentication code
 * generated by the signin process (see phase 2 below).
 *
 * @type {import('express').RequestHandler<?, ?, ?, { redirect_to: string }>}
 */
export async function startMsalAuthentication(request, response) {
	// A nonce is generated to identify the OIDC as originating from our
	// application, and for this OIDC attempt only. The nonce is later returned as
	// idTokenClaim within the authentication result fetched by the authentication
	// code, whereupon it is validated against the original nonce retained in the
	// session. Note that this is not susceptible to a downgrade attack like PKCE
	// because the verification is enforced locally and not in the auth server.
	const nonce = new msalNode.CryptoProvider().createNewGuid();
	// The url from which the OpenID Connect flow was triggered by the
	// application. Ultimately, we will forward the user to this route at the
	// end of the authentication journey.
	const postSigninRedirectUri = request.query.redirect_to || '/';

	// Set the data that will exist throughout the OpenID Connect flow lifecycle.
	// This will be consumed in phase 2 to verify the inbound redirect from the
	// MSAL authentication.
	authSession.setAuthenticationData(request.session, {
		nonce,
		postSigninRedirectUri
	});
	// Generate – and then redirect to – a url where the user will authenticate
	// against MSAL using their PINS account.
	response.redirect(await authService.getAuthCodeUrl({ nonce }));
}

/**
 * Phase 2 – Handle redirect from MSAL signin url post-authentication
 *
 * Once the user has authenticated via MSAL, they are redirected back to the
 * application, where a `code` property generated by MSAL will be present in the
 * query params, and can be used to acquire an access token / account info. As
 * outlined in phase 1, we use the `nonce` stored in the session to validate the
 * request.
 *
 * Authentication is essentially complete when the `account` details from an
 * authentication result are assigned to the session.
 *
 * @type {import('express').RequestHandler<?, ?, ?, { code?: string }>}
 */
export async function completeMsalAuthentication(request, response) {
	const { nonce, postSigninRedirectUri } = authSession.getAuthenticationData(request.session);

	if (request.query.code) {
		const authenticationResult = await authService.acquireTokenByCode(request.query.code);

		// After acquiring an authentication result from MSAL, verify that the
		// result is signed by the nonce for this authentication attempt. This check
		// prevents against replay attacks and CSRF attacks (note, that a CSRF
		// "attack" is still possible if an attacker wants to send a spoofed error
		// response directly to redirectUri as the nonce would not be in play, but
		// such a request has no nefarious effect on the application and would
		// basically be a waste of time).
		if (authenticationResult?.idTokenClaims.nonce === nonce) {
			authSession.setAccount(request.session, authenticationResult.account);

			response.redirect(postSigninRedirectUri);
		} else {
			pino.error({ nonce, authenticationResult }, 'Authentication failed. Nonce did not match.');
			response.redirect('/unauthenticated');
		}
	} else {
		// todo: determine what an actual MSAL error sent to this controller looks
		// like so it can be correctly fed into pino
		pino.error('Authentication failed – MSAL was unable to generate authentication code.');
		response.redirect('/unauthenticated');
	}
}

/**
 * Destroy any data belonging to an authenticated user. This endpoint will be
 * invoked by MSAL after single sign-out occurs.
 *
 * @type {import('express').RequestHandler}
 */
export async function handleSignout(req, response) {
	const account = authSession.getAccount(req.session);

	if (account) {
		await Promise.all([
			promisify(req.session.destroy.bind(req.session))(),
			authService.clearCacheForAccount(account)
		]);
	}

	pino.info('[WEB] clearing session:', req.session);

	response.clearCookie('connect.sid', { path: '/' }).status(200).end();
}
