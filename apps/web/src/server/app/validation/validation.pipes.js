import { composeMiddleware, createValidator, mapMulterErrorToValidationError } from '@pins/express';
import * as validation from '@pins/validation';
import { body, checkSchema, validationResult } from 'express-validator';
import multer from 'multer';
import { memoryStorage } from '../../lib/multer.js';
import * as validationSession from './validation-session.service.js';

// The UI routes can interact with these validators directly without parsing the body
export { validateAppellantName, validateLocalPlanningDepartment, validatePlanningApplicationReference } from '@pins/validation';

/** @typedef {import('@pins/validation').IncompleteReasons} IncompleteReasons */
/** @typedef {import('@pins/validation').IncompleteReasonType} IncompleteReasonType */
/** @typedef {import('@pins/validation').InvalidReasons} InvalidReasons */
/** @typedef {import('@pins/validation').InvalidReasonType} InvalidReasonType */

/**
 * @typedef {Object} ValidationLocals
 * @property {string} serviceName - The name of the service to be displayed in the page header.
 * @property {string} serviceUrl - The root url of the service.
 */

/**
 * Expose the default template locals to nunjucks for the validation domain.
 *
 * @type {import('express').RequestHandler<any, any, any, any, ValidationLocals>}
 * */
export const registerValidationLocals = (_, response, next) => {
	response.locals.serviceName = 'Appeal a planning decision';
	response.locals.serviceUrl = '/validation';
	next();
};

/** @typedef {import('@pins/validation').Address} UnparsedAppealSiteBody */
/** @typedef {{ Address: import('@pins/validation').Address}} ParsedAppealSiteBody */

export const validateAppealSite = composeMiddleware(function parseAppealSiteBody(request, _, next) {
	request.body = { Address: request.body };
	next();
}, validation.validateAppealSite);

export const validateReviewOutcomeConfirmation = createValidator(
	body('confirmation')
		.custom((value, { req }) => {
			const status = validationSession.getReviewOutcomeStatus(req.session, req.params?.appealId);

			return status === 'incomplete' ? Boolean(value) : true;
		})
		.withMessage('Confirm you have completed all follow-up tasks and emails')
);

export const handleUploadedDocuments = createValidator(
	checkSchema({
		files: {
			notEmpty: {
				errorMessage: 'Select a file'
			}
		}
	}),
	multer({
		storage: memoryStorage,
		limits: {
			fileSize: 1 * Math.pow(1024, 2 /* MBs*/)
		}
	}).array('files'),
	mapMulterErrorToValidationError
);

/**
 * @typedef {Object} UnparsedIncompleteOutcomeBody
 * @property {(IncompleteReasonType | 'missingDocuments')[]=} reasons - An array of incomplete reason types.
 * @property {IncompleteReasonType[]=} documentReasons - A subset of reason types belonging to missing documents.
 * @property {string=} otherReasons - Any text describing the other reasons when
 * the `reasons` contains and `otherReasons` entry.
 */

/** @typedef {import('./validation.service').IncompleteAppealData} ParsedIncompleteOutcomeBody */

const validateIncompleteOutcome = composeMiddleware(
	// As the UI collects `missing*` reason types under a conditional selection of
	// reasons belonging to a 'Missing documents' checkbox, we must first perform
	// UI-only validation on this pattern.
	body('documentReasons')
		.if(body('reasons').custom((value = []) => value.includes('missingDocuments')))
		.isArray({ min: 1 })
		.withMessage('Select which documents are missing or wrong'),
	/**
	 * Transform the raw posted body generated by the form data into the schema
	 * accepted by the api. This allows us to funnel the frontend data through
	 * the api validators.
	 *
	 * @type {import('express').RequestHandler<any, any, UnparsedIncompleteOutcomeBody | ParsedIncompleteOutcomeBody>}
	 */
	function parseIncompleteOutcomeBody(request, _, next) {
		const { reasons = [], documentReasons = [], otherReasons } = /** @type {UnparsedIncompleteOutcomeBody} */ (request.body);

		request.body = {
			status: 'incomplete',
			reasons: [...documentReasons, ...reasons]
				// This 'Missing documents' reason, passed as part of the selected
				// reasons but handled earlier in the validation, is now discarded
				.filter((reasonType) => reasonType !== 'missingDocuments')
				.reduce(
					(reasonsMap, reasonType) => ({
						...reasonsMap,
						[reasonType]: reasonType === 'otherReasons' ? otherReasons : true
					}),
					/** @type {IncompleteReasons} */ ({})
				)
		};
		next();
	},
	validation.validateIncompleteReviewOutcome,
	(request, response, next) => {
		const result = validationResult(request);

		if (!result.isEmpty()) {
			response.locals.errors = result.mapped();
			// the local `documentReasons` is a specific subset of reasons that trumps
			// any general reason, so discard any regular `reasons` error when this
			// key is present
			if (response.locals.errors.documentReasons) {
				delete response.locals.errors.reasons;
			}
		}
		next();
	}
);

/**
 * @typedef {Object} UnparsedInvalidOutcomeBody
 * @property {InvalidReasonType[]=} reasons - An array of invalid reason types.
 * @property {string=} otherReasons - Any text describing the other reasons when
 * the `reasons` contains and `otherReasons` entry.
 */

/** @typedef {import('./validation.service').InvalidAppealData} ParsedInvalidOutcomeBody */

const validateInvalidOutcome = createValidator(
	/**
	 * Transform the raw posted body as generated by the form data into the schema
	 * accepted by the package. This allows us to funnel the frontend data through
	 * the api validators.
	 *
	 * @type {import('express').RequestHandler<any, any, UnparsedInvalidOutcomeBody | ParsedInvalidOutcomeBody>}
	 */
	function parseInvalidOutcomeBody(request, _, next) {
		const { reasons = [], otherReasons } = /** @type {UnparsedInvalidOutcomeBody} */ (request.body);

		request.body = {
			status: 'invalid',
			reasons: reasons.reduce(
				(reasonsMap, reasonType) => ({
					...reasonsMap,
					[reasonType]: reasonType === 'otherReasons' ? otherReasons : true
				}),
				/** @type {InvalidReasons} */ ({})
			)
		};
		next();
	},
	validation.validateInvalidReviewOutcome
);

/**
 * Interim validator that invokes the correct validator for the given review
 * outcome status.
 *
 * @type {import('express').RequestHandler}
 */
export const validateReviewOutcome = (req, res, next) => {
	switch (req.body.status) {
		case 'incomplete':
			validateIncompleteOutcome(req, res, next);
			break;

		case 'invalid':
			validateInvalidOutcome(req, res, next);
			break;

		case 'valid':
			validation.validateValidReviewOutcome(req, res, next);
			break;

		default:
			next(new Error('Review outcome status could not be determined'));
	}
};
